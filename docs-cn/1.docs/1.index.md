---
icon: i-lucide-compass
---

# 介绍

> Nitro 是一个全栈框架，兼容任何 runtime。它为你的 Vite 应用扩展了生产级服务器。

Vite 的主要目的是构建前端应用。它提供了一个快速的 dev server 来转换和提供资源，支持 HMR，但不包含生产服务器。

在创建 SPA 时，通常需要添加 API routes——无论是为了绕过 CORS、使用 API token 调用服务，还是实现你自己的后端逻辑。Nitro 让你在项目 `routes/` 目录中创建 server 和 API routes。你甚至可进一步，通过创建 `server.ts` 文件来完全控制整个 server entry。凭借其高级别和 runtime 不可知的方法，Nitro 允许你使用任何 HTTP 库，例如 [Elysia](https://elysiajs.com/)、[h3](https://h3.dev) 或 [Hono](https://hono.dev)。

但这还不是全部：运行 `vite build` 也会将你的后端和前端代码构建到优化的 `.output/` 文件夹中。这个输出不仅兼容 Node.js、Bun 和 Deno，还兼容许多托管平台，无需任何配置。这意味着你可以将全栈 Vite 应用部署到 Cloudflare Workers、Netlify、Vercel 等，而无需更改任何代码行，同时利用平台特性如 ESR、ISR 和 SWR。

Nitro 服务器具有高性能。通过将代码分割与编译路由相结合，它消除了对 runtime router 的需求，只保留了最小的编译逻辑。这使其非常适合 serverless hosting，因为无论项目大小，启动时间几乎为 0ms，只有处理传入请求所需的代码会被加载和执行。

拥有服务器还解锁了服务器端渲染。你可以使用喜欢的模板引擎渲染 HTML，或者直接在服务器上使用组件库如 React、Vue 或 Svelte。你甚至可以通过客户端 hydration 实现完整的 universal rendering。Nitro 提供了基础和渐进式方法来实现你的目标。

服务器数据存储通常是必需的，Nitro 包含了一个 runtime 不可知的键值存储层。它默认使用内存存储，但你可以连接超过 20 种不同的驱动程序（FS、Redis、S3 等），将它们附加到不同的命名空间，并在不更改代码的情况下交换它们。

缓存是任何 Web 服务器的关键部分，这就是为什么 Nitro 支持对 server routes 和 server functions 进行缓存，直接由服务器存储支持（通过 `cache` 命名空间）。

当键值存储不够时，Nitro 还包含内置的 SQL 数据库。它默认为 SQLite，但你可以使用相同的 API 连接和查询超过 10 个数据库（Postgres、MySQL、PGLite 等）。

最后但同样重要的是，Nitro 可以用作构建你自己的 meta-framework 的基础。流行的框架如 Nuxt、SolidStart 和 TanStack Start 完全或部分地利用了 Nitro。

准备好尝试了吗？跳转到[快速开始](/docs/quick-start)。